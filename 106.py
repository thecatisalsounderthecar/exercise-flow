import numpy as np
# a=np.arange(0,10)
# print(a)
# A=a>5
# print(A)
# print(a[A])
# # 布尔索引，将布尔数组A作为索引参数放入a的方括号后。

# # 需求：>5的全部换成1，<=5的全部换成0
# a[a<=5]=0
# a[a>5]=1
# # 以上两句赋值顺序不可颠倒，不然会把前面赋值为1的也计入<=5的范围，从而把整个数组都赋值为0
# print(a)

# 需求：把>5的数组元素全部加上520
# a[a>5]+=520
# print(a)

# b=np.array([
#     [0,1,2,3,4],
#     [5,6,7,8,9],
#     [10,11,12,13,14],
#     [15,16,17,18,19],
#     [21,22,23,24,25]]
# )
# b[-1]-=1
# print(b)

# # 需求：把>5的行第三列重新赋值为520
# b[b[:,2]>5,2]=520
# print(b)
# # for i in b.shape()[0]:#报错'tuple' object is not callable
# #     b[b[i,:]>5]=520

# # 需求：找出数组中偶数或小于7的元素
# c=np.array([
#     [0,1,2,3,4],
#     [5,6,7,8,9],
#     [10,11,12,13,14],
#     [15,16,17,18,19],
#     [20,21,22,23,24]]
# )
# cs=c[(c%2==0)|(c<7)]
# # 条件分别用括号括起来，不然或的优先级比==高，会变成c%2==(0|c)<7
# # numpy中逐元素或是|,详见以下运算规则
# print(cs)

# d=np.arange(36).reshape(9,4)
# print(d)
# # print(d[[4,3,0,6]])
# # print(d[[1,2,3,5],[0,1,3,3]])
# print(d[:,[1,2]])
# # 两层括号：第一层表示索引开始，第二层表示索引是个数组（就像前面索引是个布尔数组一样）

# # 维数对不上则取出索引自己
# e=np.arange(10)
# idx=np.array([[0,2],[1,3]])
# print(e[idx])

f=np.arange(10).reshape(2,5)
print(f.transpose())
# 二维swapaxes,交换原本的0轴和1轴位置，相当于转置
print(f.swapaxes(1,0))
g=np.array(
    [
        [
            [1,2,3,0],
            [4,5,6,0],
            [1,1,1,1]
        ],
        [
            [7,8,9,10],
            [11,12,13,14],
            [1,1,1,1]
        ]
    ]
)
# 数组大小(2,3,4)
# 原轴索引(0,1,2)
print(g.swapaxes(2,1))
# 交换原轴索引为1和2的轴，相当于对每一个零轴上的块，转置这两个轴。
# 注意是每一块转置而非旋转。
# 新数组大小(2,4,3)

h=list(range(5))
print(h)
e=np.random.permutation(10)
# 只有一维的可以直接传入参数，相当于range(10)生成
f=np.arange(10).reshape(2,5)
print('生成的二维数组：')
print(f)
f1=np.random.permutation(f)
# f1接收排序结果
print('排序后的原二维数组:')
print(f1)
# 输出结果有概率和原数组相同，因为是按行重排，这里又只有两行
